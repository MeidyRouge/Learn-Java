##第1章　簡単なプログラムの作成  
■ソースファイルモードの操作  
javacコマンド・・・コンパイル  
javaコマンド・・・実行  
例：package aに属するAクラスのクラスファイルを生成するためのコマンドは？  
javac a/A.java  
java a/A  

■パッケージのインポート  
java.langパッケージに属するクラスは、インポートしなくても自動的にインポートされる。  
例：package com.sample.test; と package com.sample; をインポートしたい場合↓  
import com.sample.test.*;  
またはimport com.sample.test;  
import com.sample.*;  
またはimport com.sample;  

##第2章　Javaの基本データ型と文字列操作
■関数
isAlphabetic(hoge)・・・hogeが文字列型か判定  
isDigit(hoge)・・・hogeが数値型か判定  
hoge.substiring(0,index)・・・hoge変数の0番目～index番目の文字列を切り出す  

##第3章　演算子と判定構造  
■switch
nullの状態で判定を行うとnullPointerExceptionが発生する。  

■リテラルのデフォルト型  
数値リテラルのデフォルトの型は、整数ならint型、浮動小数点数ならdouble型  



##第6章　インスタンスとメソッド  
■モジュールの設定ファイルの記述  
requires・・・そのモジュールが利用する他のモジュール名を記載  
exports・・・パッケージを公開する  
※ＡクラスからＢクラスをrequires,BクラスからＡクラスをrequiresした場合、相互依存の状態となり、コンパイルエラーになる。  

##第7章　クラスの継承、インターフェース、抽象クラス  
■継承と実現のルール  
クラス同士の継承は多重禁止。単一継承のみ。  
インターフェース同士は多重継承・多重実現が可能。  
インターフェースに宣言する抽象メソッドには、処理内容を記載できない。  
インターフェースに宣言されたメソッドは、必ず実装しなくてはならない。  
ポリモーフィズムは、上位のクラスやインターフェース型としてインスタンスを扱うこと。インスタンスを生成する時に宣言しているデータ型は、継承や実現されたものか？と考える。  
継承や実現されていないものをデータ型として宣言すれば、当然コンパイルエラーとなる。  

■抽象クラスの記述ルール  
抽象クラスには、抽象メソッドと具象メソッドの両方を記述できる。  
抽象メソッドのルール：①abstractで修飾すること。②処理を実装してはいけないこと。  


##第8章　ラムダ式  
■ラムダ式からアクセスできる変数  
ラムダ式内で宣言されたローカル変数をラムダ式内で利用するには、その変数がfinalで宣言されなければコンパイルエラーになる。 

##第9章　API  
■java.util.Listインターフェースのofメソッドのルール  
ofメソッドで作成したコレクションは変更できない。  
clearメソッドなどでコレクションの要素に変更を加えた場合、実行時に例外（UnsupportedOperationException）がスローされる。  


##第11章　モジュールシステム  
■Javaコマンド  
jdeps・・・クラスの依存関係を調べる  
java --show-module-resolution・・・モジュールの依存関係を調べる  
jmod・・・モジュールを作成する  

■JDKをモジュール化する理由  
①アプリのモジュールを作るときに、そのアプリが使うJREのモジュールを含めると、Javaがインストールされていないプラットフォームでも実行できる  
（＝アプリケーションモジュールとJDKのモジュールのリンクが用意に構築できる）  
②パッケージ単位で情報隠ぺいが可能なため、セキュリティとメンテナンス性が向上する。  