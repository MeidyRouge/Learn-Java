2##第1章　簡単なプログラムの作成  
■ソースファイルモードの操作  
javacコマンド・・・コンパイル  
javaコマンド・・・実行  
例：package aに属するAクラスのクラスファイルを生成するためのコマンドは？  
javac a/A.java  
java a/A  

■パッケージのインポート  
java.langパッケージに属するクラスは、インポートしなくても自動的にインポートされる。  
例：package com.sample.test; と package com.sample; をインポートしたい場合↓  
import com.sample.test.*;  
またはimport com.sample.test;  
import com.sample.*;  
またはimport com.sample;  

■エントリーポイントの定義  
エントリーポイントになるのは、String型配列型の引数を受け取るものだけ。

##第2章　Javaの基本データ型と文字列操作
■関数
isAlphabetic(hoge)・・・hogeが文字列型か判定  
isDigit(hoge)・・・hogeが数値型か判定  
hoge.substiring(0,index)・・・hoge変数の0番目～index番目の文字列を切り出す  

##第3章　演算子と判定構造  
■switch
nullの状態で判定を行うとnullPointerExceptionが発生する。  

■リテラルのデフォルト型  
数値リテラルのデフォルトの型は、整数ならint型、浮動小数点数ならdouble型  

■キャストの互換性  
short型⇒Integer型⇒Long型で互換性がある。  
一方で、Long型⇒String型の互換性はない。  
同種の小さな型から大きな型への互換性はあるが、種別が異なるとコンパイルエラー。  

##第4章　制御構造  
■後置インクリメント  
x++; のような後置インクリメントは、処理が終わった後に++される。

##第6章　インスタンスとメソッド  
■モジュールの設定ファイルの記述  
requires・・・そのモジュールが利用する他のモジュール名を記載  
exports・・・パッケージを公開する  
※ＡクラスからＢクラスをrequires,BクラスからＡクラスをrequiresした場合、相互依存の状態となり、コンパイルエラーになる。  

■メソッドの定義  
public void method() ⇒ returnは省略  
public string method() ⇒ return string型  
public boolean method() ⇒ return boolean型  
public char method() ⇒ return char型  
例外）public void method ⇒ return; ならOK。returnを使用しているが、値を戻していないので問題なし。  

##第7章　クラスの継承、インターフェース、抽象クラス  
■継承と実現のルール  
クラスの多重継承は禁止。単一継承のみ。  
インターフェース同士は多重継承・多重実現が可能。  
インターフェースに宣言する抽象メソッドには、処理内容を記載できない。  
インターフェースに宣言されたメソッドは、必ず実装しなくてはならない。  
ポリモーフィズムは、上位のクラスやインターフェース型としてインスタンスを扱うこと。インスタンスを生成する時に宣言しているデータ型は、継承や実現されたものか？と考える。  
継承や実現されていないものをデータ型として宣言すれば、当然コンパイルエラーとなる。  

■オーバーライドとオーバーロードの処理優先度  
AクラスのインスタンスをA型で扱っている場合⇒Aクラスで定義したメソッドが呼び出される。  
Aクラスを継承したBクラスのインスタンスをA型で扱っている場合⇒Aクラスで定義したメソッドが呼び出される。  
例外）インスタンスにオーバーライドしたメソッドがあればそのメソッドを呼び出す。  
メソッドの引数に互換性がある場合（Collection型とList型)、より厳密の方を呼び出す。引数がList型の場合、List型の方を呼び出す。

■菱形継承問題  
Aクラスを継承したBインターフェース と Aクラスを継承したCインターフェースがあるとする。  
BインターフェースとCインターフェースを同時にＤクラスに多重実現・多重継承した時、ＢとＣは互いにＡを継承しているため、菱形の形となる。  
この場合、コンパイルエラー。解決法：B.super.hoge()のように、どちらのインターフェースの実装を使うか指定する。  

■抽象クラスの記述ルール  
抽象クラスには、抽象メソッドと具象メソッドの両方を記述できる。  
抽象メソッドのルール：①abstractで修飾すること。②処理を実装してはいけないこと。  
具象メソッドのルール：①abstractで修飾してはいけない。②処理が実装されていること。

■オーバーライドのルール  
シグニチャが同じであること。  
戻り値型は同じ型か、サブクラスの型であること。  
アクセス修飾子は同じか、より緩くすること。public>protected>なし＞private　
throwsで宣言する例外は、スローする例外と同じ型か、サブクラスの型であること。  

privateのメンバは、そのメンバを定義したクラスでしか利用できない。  
よって、サブクラスにオーバーライドした場合、コンパイルエラー。  


■共変戻り値  
メソッドをオーバーライドした際に、戻り値の型をサブクラスやサブインターフェースにできる機能のこと。  
B型メソッドが定義されたBインターフェースと、C型メソッドが定義されたCインターフェースを継承したDインターフェースがあった場合、 
B型のメソッドを継承するか、C型のメソッドを継承するか不明瞭のため、コンパイルエラー。  

■可変長引数
可変長引数はコンパイル時に配列に置き換わる。  
つまりpublic sample(String[] array){}とpublic sample(String... array){}は同じ。  

■ローカル変数の有効範囲  
同名のフィールドとローカル変数がある場合、ローカル変数が優先される。  
Aクラスのローカル変数aと、AクラスのAメソッドに定義された変数aがあるとして、  
Aクラスを継承したBクラスから、Aクラスの変数aを呼び出した場合、  
ローカル変数の方が優先されるということ。  


##第8章　ラムダ式  
■ラムダ式からアクセスできる変数  
ラムダ式内で宣言されたローカル変数をラムダ式内で利用するには、その変数がfinalで宣言されなければコンパイルエラーになる。 

##第9章　API  
■java.util.Listインターフェースのofメソッドのルール  
ofメソッドで作成したコレクションは変更できない。  
clearメソッドなどでコレクションの要素に変更を加えた場合、実行時に例外（UnsupportedOperationException）がスローされる。  

■Arraysクラスのmismatchメソッド,compareメソッド
mismatchメソッド：引数で渡された配列を先頭から比較し、一致しない要素のインデックスを返却する。3番目の要素数が一致しない場合、2を返却。  
compareメソッド：要素数を辞書順に比較し、第1引数＜第2引数の場合、負の数を返す。第1引数＞第2引数の場合、正の数を返す。一致した場合、0を返す。

■メソッド参照  
再利用しない簡単な処理を記述するなら、ラムダ式を使って省略する。  
一方で、ラムダ式ではなく既存のメソッドを流用する場合、メソッド参照が使える。  
クラス名::メソッド名 あるいは インスタンス名::メソッド名 と記述することで、既存のメソッドを流用することが出来る。  

■Mathクラスのroudメソッド/powメソッド  
round：小数点以下の値を四捨五入する。  
pow：第1引数の値を第2引数の値で累乗する。Math.pow(2,3)は、2を3乗する。


##第10章　例外処理  
■例外処理のルール  
try-catch-finally もしくは try-finallyの形をとる。finallyは省略可能。
catchブロックは複数記述可能だが、tryとfinallyは1つだけ。  

■検査例外と非検査例外  
java.lang.Exceptionクラスのサブクラス⇒検査例外（例外処理の記述が必要）  
RuntimeExceptionクラスのサブクラス⇒非検査例外（例外処理の記述は必須ではない）  
FileNotFoundExceptionは、java.io.IOExceptionのサブクラス。IOExceptionは、Exceptionのサブクラス。（つまり検査例外）  
IndexOutOfBoundsExceptionは、RuntimeExceptionのサブクラス。（つまり非検査例外）  

■try-with-resources構文  
例外発生時、自動的にリソースのcloseメソッドを呼び出し、リソースを解放する構文。  
close()⇒catch⇒finallyの順で処理が行われる。  


##第11章　モジュールシステム  
■Javaコマンド  
jdeps・・・クラスの依存関係を調べる  
java --show-module-resolution・・・モジュールの依存関係を調べる  
jmod・・・モジュールを作成する  

■JDKをモジュール化する理由  
①アプリのモジュールを作るときに、そのアプリが使うJREのモジュールを含めると、Javaがインストールされていないプラットフォームでも実行できる  
（＝アプリケーションモジュールとJDKのモジュールのリンクが用意に構築できる）  
②パッケージ単位で情報隠ぺいが可能なため、セキュリティとメンテナンス性が向上する。  